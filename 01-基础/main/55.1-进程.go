package main

import (
	"fmt"
	"time"
)

/**
* 计算机知识
* 1. 进程: 进程就是程序在执行操作系统的一次执行过程, 是系统进行资源分配和调度的基本单位; 如我们打开的Chrome浏览器的窗口就是一个进程, 多个浏览器窗口就是多个线程(注意不是标签页)
* 2. 线程: 线程是进程的一个执行实例, 是程序执行的最小单元; 如浏览器中的JS引擎
* 3. 一个进程可以创建和销毁多个进程, 同一个进程中的线程可以并发执行
* 4. 一个程序至少要有一个进程, 一个进程至少要有一个线程
* 5. 多线程程序在单核上运行, 就是并发; 例如一个cpu执行10个线程, 每个线程执行10毫秒(时间片轮询操作), 从人的角度来看, 10个线程同时执行, 从计算机角度看, 同一时间内只有一个线程在执行
* 6. 多线程程序在多核上运行, 就是并行; 例如10个cpu执行10个线程, 每个线程执行10毫秒, 从人角度看, 是个线程同时执行, 从计算机角度看, 同一时间10个线程同时执行, 每个线程占一个cpu
*
* Go语言知识
* 1. Go主线程理解为是进程; 一个go线程上可以启动多个协程; 协程可以理解为是轻量级的线程(编译器做了优化)
* 2. 协程特点: 独立的栈空间, 共享的堆空间, 调度由用户控制, 轻量级的线程
* 3. 主线程和协程同时执行, 如果主线程执行完了, 线程还没有执行完, 那么协程便会随着主线的终止而终止
* 4. 主线程是一个物理线程, 直接作用在cpu上; 是重量级的非常消耗cpu资源
* 5. 协程(goroutine)是从主线程开启的, 是轻量级的线程, 是逻辑态; 对资源消耗相对较小
* 6. Go语言中最精华的部分就是协程, go主线程可以轻松开启上万个协程; 而其他语言的并发机制是基于线程的, 开启过多的线程, 资源耗费巨大; 所以go在并发上很有优势
*
* MPG模式
* M: 操作系统的主线程, 是物理线程
* P: 协程执行需要的上下文
* G: 协程
 */
func test() {
	for i := 1; i <= 100; i++ {
		fmt.Println("========test======", i)
		time.Sleep(time.Second)
	}
}

func main() {
	go test() // 使用go关键字开启协程运行test方法
	for i := 1; i <= 10; i++ {
		fmt.Println("========main======", i)
		time.Sleep(time.Second)
	}
}
